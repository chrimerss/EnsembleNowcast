/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.11 (r5880) - 30 Nov 2015 17:19
*/
#include <stdio.h>
#include <sys/time.h>
#include <omp.h>
#include "swe_parameters.h"
#include "rok_instrumentation.h"

void swe_fun_b(double t, double X[], double Xb[], double Yb[]);
void swe_fun_b_init();
void swe_fun_b_cleanup();
void swe_fun_main_b(int M, int N, double X[], double Xb[], double dx, double dy, double Yb[]);
    
// timing data
double funb_time;
double funb_count;

#define Xdim (NX+2)
#define Ydim (NY+2)

//double tx2d[Xdim][Ydim], tu2d[Xdim][Ydim], tv2d[Xdim][Ydim];
double Hx[Xdim-1][Ydim-1], Ux[Xdim-1][Ydim-1], Vx[Xdim-1][Ydim-1];
double Hxb[Xdim-1][Ydim-1], Uxb[Xdim-1][Ydim-1], Vxb[Xdim-1][Ydim-1];
double Hy[Xdim-1][Ydim-1], Uy[Xdim-1][Ydim-1], Vy[Xdim-1][Ydim-1];
double Hyb[Xdim-1][Ydim-1], Uyb[Xdim-1][Ydim-1], Vyb[Xdim-1][Ydim-1];

void swe_fun_b_init() {
   funb_count = 0;
   funb_time = 0.0;
}

void swe_fun_b_cleanup() {
   rok_record_time(funb_time/funb_count, TIMER_SWE_FUN_B);
}

//#include "DIFFSIZES.inc"
/*  Hint: ISIZE1OFX should be the size of dimension 1 of array X*/

/*
  Differentiation of swe_fun_main in reverse (adjoint) mode:
   gradient     of useful results: Y[_:_]
   with respect to varying inputs: X[_:_] Y[_:_]
   Plus diff mem management of: Hx:in Hx[0:128+2-1-1]:in Hy:in
                Hy[0:128+2-1-1]:in Ux:in Ux[0:128+2-1-1]:in Uy:in
                Uy[0:128+2-1-1]:in Vx:in Vx[0:128+2-1-1]:in Vy:in
                Vy[0:128+2-1-1]:in X:in Y:in
*/
void swe_fun_main_b(int M, int N, double X[], double Xb[], double dx, double 
        dy, double Yb[]) {
    int i, j;
    double tmp;
    double tmp0;
    double tmp1;
    double tmp2;
    double tmp3;
    double tmp4;
    double tempb8;
    double tempb7;
    double tempb6;
    double tempb5;
    double tempb4;
    double tempb3;
    double tempb2;
    double tempb1;
    double tempb0;
    double tmpb4;
    double tmpb3;
    double tmpb;
    double tmpb2;
    double tmpb1;
    double tmpb0;
    double tempb;
    int ii2;
    int ii1;
    //   int l;
    //   l = M * N;
    // Initialize derivatives
#pragma omp parallel private(i, j)
{
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-1; ++j) {
            Hx[i][j] = 0.0;
            Hxb[i][j] = 0.0;
        }
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-1; ++j) {
            Hy[i][j] = 0.0;
            Hyb[i][j] = 0.0;
        }
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-1; ++j) {
            Ux[i][j] = 0.0;
            Uxb[i][j] = 0.0;
        }
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-1; ++j) {
            Uy[i][j] = 0.0;
            Uyb[i][j] = 0.0;
        }
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-1; ++j) {
            Vx[i][j] = 0.0;
            Vxb[i][j] = 0.0;
        }
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-1; ++j) {
            Vy[i][j] = 0.0;
            Vyb[i][j] = 0.0;
        }
}
    /*     for (i = 0; i < M; i++) {
      for(j = 0; j < N; j++) {
         int p = i * M + j;
         tx2d[i][j] = X[p];
         tu2d[i][j] = X[l+p];
         tv2d[i][j] = X[2*l+p];
      }
   } */
    // Unpack current state
    //#define x2d(V, I, J) (tx2d[(I)][(J)])
    //#define u2d(V, I, J) (tu2d[(I)][(J)])
    //#define v2d(V, I, J) (tv2d[(I)][(J)])
    // Compute x-direction averages
#pragma omp parallel private(i, j)
{
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-2; ++j)
            Hx[i][j] = (X[(i+1)*M+(j+1)]+X[i*M+(j+1)])/2.0;
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-2; ++j)
            Ux[i][j] = (X[M*N+(i+1)*M+(j+1)]+X[M*N+i*M+(j+1)])/2.0;
    #pragma omp for schedule(static)
    for (i = 0; i < M-1; ++i)
        for (j = 0; j < N-2; ++j)
            Vx[i][j] = (X[2*M*N+(i+1)*M+(j+1)]+X[2*M*N+i*M+(j+1)])/2.0;

    // Compute y-direction averages
    #pragma omp for schedule(static)
    for (i = 0; i < M-2; ++i)
        for (j = 0; j < N-1; ++j)
            Hy[i][j] = (X[(i+1)*M+(j+1)]+X[(i+1)*M+j])/2.0;
    #pragma omp for schedule(static)
    for (i = 0; i < M-2; ++i)
        for (j = 0; j < N-1; ++j)
            Uy[i][j] = (X[M*N+(i+1)*M+(j+1)]+X[M*N+(i+1)*M+j])/2.0;
    #pragma omp for schedule(static)
    for (i = 0; i < M-2; ++i)
        for (j = 0; j < N-1; ++j)
            Vy[i][j] = (X[2*M*N+(i+1)*M+(j+1)]+X[2*M*N+(i+1)*M+j])/2.0;
}

    for (i = N-1; i > -1; --i) {
        tmpb4 = Yb[2*M*N + (M-1)*M + i];
        Yb[2*M*N + (M-1)*M + i] = 0.0;
        Yb[2*M*N + (M-2)*M + i] = Yb[2*M*N + (M-2)*M + i] + tmpb4;
    }
    for (i = N-1; i > -1; --i) {
        tmpb3 = Yb[M*N + (M-1)*M + i];
        Yb[M*N + (M-1)*M + i] = 0.0;
        Yb[M*N + (M-2)*M + i] = Yb[M*N + (M-2)*M + i] - tmpb3;
    }
    for (i = N-1; i > -1; --i) {
        tmpb2 = Yb[(M-1)*M + i];
        Yb[(M-1)*M + i] = 0.0;
        Yb[(M-2)*M + i] = Yb[(M-2)*M + i] + tmpb2;
    }
    for (i = N-1; i > -1; --i) {
        tmpb1 = Yb[2*M*N + 0*M + i];
        Yb[2*M*N + 0*M + i] = 0.0;
        Yb[2*M*N + 1*M + i] = Yb[2*M*N + 1*M + i] + tmpb1;
    }
    for (i = N-1; i > -1; --i) {
        tmpb0 = Yb[M*N + 0*M + i];
        Yb[M*N + 0*M + i] = 0.0;
        Yb[M*N + 1*M + i] = Yb[M*N + 1*M + i] - tmpb0;
    }
    for (i = N-1; i > -1; --i) {
        tmpb = Yb[0*M + i];
        Yb[0*M + i] = 0.0;
        Yb[1*M + i] = Yb[1*M + i] + tmpb;
    }
    for (i = M-1; i > -1; --i) {
        Yb[2*M*N + i*M + (N - 2)] = Yb[2*M*N + i*M + (N - 2)] - Yb[2*M*N + i*M
            + (N - 1)];
        Yb[2*M*N + i*M + (N - 1)] = 0.0;
    }
    for (i = M-1; i > -1; --i) {
        Yb[M*N + i*M + (N - 2)] = Yb[M*N + i*M + (N - 2)] + Yb[M*N + i*M + (N 
            - 1)];
        Yb[M*N + i*M + (N - 1)] = 0.0;
    }
    for (i = M-1; i > -1; --i) {
        Yb[i*M + (N - 2)] = Yb[i*M + (N - 2)] + Yb[i*M + (N - 1)];
        Yb[i*M + (N - 1)] = 0.0;
    }
    for (i = M-1; i > -1; --i) {
        Yb[2*M*N + i*M + 1] = Yb[2*M*N + i*M + 1] - Yb[2*M*N + i*M + 0];
        Yb[2*M*N + i*M + 0] = 0.0;
    }
    for (i = M-1; i > -1; --i) {
        Yb[M*N + i*M + 1] = Yb[M*N + i*M + 1] + Yb[M*N + i*M + 0];
        Yb[M*N + i*M + 0] = 0.0;
    }
    for (i = M-1; i > -1; --i) {
        Yb[i*M + 1] = Yb[i*M + 1] + Yb[i*M + 0];
        Yb[i*M + 0] = 0.0;
    }

    for (i = M-2; i > 0; --i)
        for (j = N-2; j > 0; --j) {
            tempb4 = -(Yb[2*M*N+i*M+j]/(dx*Hx[i][j-1]));
            tempb5 = Yb[2*M*N+i*M+j]/(dx*Hx[i-1][j-1]);
            tempb6 = -(Yb[2*M*N+i*M+j]/dy);
            tempb7 = tempb6/Hy[i-1][j];
            tempb8 = -(tempb6/Hy[i-1][j-1]);
            Uxb[i][j - 1] = Uxb[i][j - 1] + Vx[i][j-1]*tempb4;
            Vxb[i][j - 1] = Vxb[i][j - 1] + Ux[i][j-1]*tempb4;
            Hxb[i][j - 1] = Hxb[i][j - 1] - Ux[i][j-1]*Vx[i][j-1]*tempb4/Hx[i]
                [j-1];
            Uxb[i - 1][j - 1] = Uxb[i - 1][j - 1] + Vx[i-1][j-1]*tempb5;
            Vxb[i - 1][j - 1] = Vxb[i - 1][j - 1] + Ux[i-1][j-1]*tempb5;
            Hxb[i - 1][j - 1] = Hxb[i - 1][j - 1] - Ux[i-1][j-1]*Vx[i-1][j-1]*
                tempb5/Hx[i-1][j-1];
            Vyb[i - 1][j] = Vyb[i - 1][j] + 2*Vy[i-1][j]*tempb7;
            Hyb[i - 1][j] = Hyb[i - 1][j] + 9.81*2*Hy[i-1][j]*tempb6/2.0 - Vy[
                i-1][j]*Vy[i-1][j]*tempb7/Hy[i-1][j];
            Vyb[i - 1][j - 1] = Vyb[i - 1][j - 1] + 2*Vy[i-1][j-1]*tempb8;
            Hyb[i - 1][j - 1] = Hyb[i - 1][j - 1] - 9.81*2*Hy[i-1][j-1]*tempb6
                /2.0 - Vy[i-1][j-1]*Vy[i-1][j-1]*tempb8/Hy[i-1][j-1];
            Yb[2*M*N + i*M + j] = 0.0;
        }

    #pragma omp parallel for private(i, j) schedule(static)
    for (i = M-2; i > 0; --i)
        for (j = N-2; j > 0; --j) {
            tempb = -(Yb[M*N+i*M+j]/dx);
            tempb0 = tempb/Hx[i][j-1];
            tempb1 = -(tempb/Hx[i-1][j-1]);
            tempb2 = -(Yb[M*N+i*M+j]/(dy*Hy[i-1][j]));
            tempb3 = Yb[M*N+i*M+j]/(dy*Hy[i-1][j-1]);
            Uxb[i][j - 1] = Uxb[i][j - 1] + 2*Ux[i][j-1]*tempb0;
            Hxb[i][j - 1] = Hxb[i][j - 1] + 9.81*2*Hx[i][j-1]*tempb/2.0 - Ux[i
                ][j-1]*Ux[i][j-1]*tempb0/Hx[i][j-1];
            Uxb[i - 1][j - 1] = Uxb[i - 1][j - 1] + 2*Ux[i-1][j-1]*tempb1;
            Hxb[i - 1][j - 1] = Hxb[i - 1][j - 1] - 9.81*2*Hx[i-1][j-1]*tempb/
                2.0 - Ux[i-1][j-1]*Ux[i-1][j-1]*tempb1/Hx[i-1][j-1];
            Vyb[i - 1][j] = Vyb[i - 1][j] + Uy[i-1][j]*tempb2;
            Uyb[i - 1][j] = Uyb[i - 1][j] + Vy[i-1][j]*tempb2;
            Hyb[i - 1][j] = Hyb[i - 1][j] - Vy[i-1][j]*Uy[i-1][j]*tempb2/Hy[i-
                1][j];
            Vyb[i - 1][j - 1] = Vyb[i - 1][j - 1] + Uy[i-1][j-1]*tempb3;
            Uyb[i - 1][j - 1] = Uyb[i - 1][j - 1] + Vy[i-1][j-1]*tempb3;
            Hyb[i - 1][j - 1] = Hyb[i - 1][j - 1] - Vy[i-1][j-1]*Uy[i-1][j-1]*
                tempb3/Hy[i-1][j-1];
            Yb[M*N + i*M + j] = 0.0;
        }
    for (i = M-2; i > 0; --i)
        for (j = N-2; j > 0; --j) {
            Uxb[i][j - 1] = Uxb[i][j - 1] - Yb[i*M+j]/dx;
            Uxb[i - 1][j - 1] = Uxb[i - 1][j - 1] + Yb[i*M+j]/dx;
            Vyb[i - 1][j] = Vyb[i - 1][j] - Yb[i*M+j]/dy;
            Vyb[i - 1][j - 1] = Vyb[i - 1][j - 1] + Yb[i*M+j]/dy;
            Yb[i*M + j] = 0.0;
        }
        
    # pragma omp parallel for private(i) schedule(static)
    for (i = 0; i < NVAR; ++i)
        Xb[i] = 0.0;

    for (i = M-3; i > -1; --i)
        for (j = N-2; j > -1; --j) {
            Xb[2*M*N + (i+1)*M + (j + 1)] = Xb[2*M*N + (i+1)*M + (j + 1)] + 
                Vyb[i][j]/2.0;
            Xb[2*M*N + (i+1)*M + j] = Xb[2*M*N + (i+1)*M + j] + Vyb[i][j]/2.0;
            Vyb[i][j] = 0.0;
        }
    for (i = M-3; i > -1; --i)
        for (j = N-2; j > -1; --j) {
            Xb[M*N + (i+1)*M + (j + 1)] = Xb[M*N + (i+1)*M + (j + 1)] + Uyb[i]
                [j]/2.0;
            Xb[M*N + (i+1)*M + j] = Xb[M*N + (i+1)*M + j] + Uyb[i][j]/2.0;
            Uyb[i][j] = 0.0;
        }
    for (i = M-3; i > -1; --i)
        for (j = N-2; j > -1; --j) {
            Xb[(i+1)*M + (j + 1)] = Xb[(i+1)*M + (j + 1)] + Hyb[i][j]/2.0;
            Xb[(i+1)*M + j] = Xb[(i+1)*M + j] + Hyb[i][j]/2.0;
            Hyb[i][j] = 0.0;
        }
    for (i = M-2; i > -1; --i)
        for (j = N-3; j > -1; --j) {
            Xb[2*M*N + (i+1)*M + (j + 1)] = Xb[2*M*N + (i+1)*M + (j + 1)] + 
                Vxb[i][j]/2.0;
            Xb[2*M*N + i*M + (j + 1)] = Xb[2*M*N + i*M + (j + 1)] + Vxb[i][j]/
                2.0;
            Vxb[i][j] = 0.0;
        }
    for (i = M-2; i > -1; --i)
        for (j = N-3; j > -1; --j) {
            Xb[M*N + (i+1)*M + (j + 1)] = Xb[M*N + (i+1)*M + (j + 1)] + Uxb[i]
                [j]/2.0;
            Xb[M*N + i*M + (j + 1)] = Xb[M*N + i*M + (j + 1)] + Uxb[i][j]/2.0;
            Uxb[i][j] = 0.0;
        }
    for (i = M-2; i > -1; --i)
        for (j = N-3; j > -1; --j) {
            Xb[(i+1)*M + (j + 1)] = Xb[(i+1)*M + (j + 1)] + Hxb[i][j]/2.0;
            Xb[i*M + (j + 1)] = Xb[i*M + (j + 1)] + Hxb[i][j]/2.0;
            Hxb[i][j] = 0.0;
        }
}

/*
  Differentiation of swe_fun in reverse (adjoint) mode:
   gradient     of useful results: Y[_:_]
   with respect to varying inputs: X[_:_] Y[_:_]
   RW status of diff variables: Hx[0:128+2-1-1][0:128+2-1-1]:(loc)
                Hy[0:128+2-1-1][0:128+2-1-1]:(loc) Ux[0:128+2-1-1][0:128+2-1-1]:(loc)
                Uy[0:128+2-1-1][0:128+2-1-1]:(loc) Vx[0:128+2-1-1][0:128+2-1-1]:(loc)
                Vy[0:128+2-1-1][0:128+2-1-1]:(loc) X[_:_]:out
                Y[_:_]:in-out
   Plus diff mem management of: Hx:in Hx[0:128+2-1-1]:in Hy:in
                Hy[0:128+2-1-1]:in Ux:in Ux[0:128+2-1-1]:in Uy:in
                Uy[0:128+2-1-1]:in Vx:in Vx[0:128+2-1-1]:in Vy:in
                Vy[0:128+2-1-1]:in X:in Y:in-out
*/
void swe_fun_b(double t, double X[], double Xb[], double Yb[]) {
   struct timeval t1, t2;
   gettimeofday(&t1, NULL);
   swe_fun_main_b(NX+2, NY+2, X, Xb, DX, DY, Yb);
   gettimeofday(&t2, NULL);
   funb_time += 1000.0 * (t2.tv_sec - t1.tv_sec) + (1.0/1000.0) * (t2.tv_usec - t1.tv_usec);
   funb_count++;
}
