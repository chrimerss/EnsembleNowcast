#!/usr/bin/env python

"""
============================================================================================
=                                                                                          =
=   DATeS: Data Assimilation Testing Suite.                                                =
=                                                                                          =
=   Copyright (C) 2016  A. Sandu, A. Attia, P. Tranquilli, S.R. Glandon,                   =
=   M. Narayanamurthi, A. Sarshar, Computational Science Laboratory (CSL), Virginia Tech.  =
=                                                                                          =
=   Website: http://csl.cs.vt.edu/                                                         =
=   Phone: 540-231-6186                                                                    =
=                                                                                          =
=   This program is subject to the terms of the Virginia Tech Non-Commercial/Commercial    =
=   License. Using the software constitutes an implicit agreement with the terms of the    =
=   license. You should have received a copy of the Virginia Tech Non-Commercial License   =
=   with this program; if not, please contact the computational Science Laboratory to      =
=   obtain it.                                                                             =
=                                                                                          =
============================================================================================
********************************************************************************************
*   ....................................................................................   *
*   Example Benchmarking:                                                                  *
*   Read results generated by the driver multi_infl_lorenz96_enkf_test_driver.py           *
*   And generate comparison plots.                                                         *
*   This is just an example made for guidance;                                             *
*                                                                                          *
*   ....................................................................................   *
********************************************************************************************
* To Run the driver:                                                                       *
* --------------------                                                                     *
*        On the linux terminal execute the following command:                              *
*           > python multi_infl_EnKF_results_reader.py                                     *
*                                                                                          *
********************************************************************************************
"""


from filtering_results_reader import *
from multi_infl_lorenz96_enkf_test_driver import inspect_output_path


standard_results_dir = os.path.abspath("Results/Filtering_Results")
out_dir_tree_structure_file = 'Results/Filtering_Results/output_dir_structure.txt'

def get_pools(list_of_dirs):
    """
    """
    # matching results directories:
    matching_dirs = []
    for d in list_of_dirs:
        _d = d.lower()
        if filter_name.lower() in _d and model_name.lower() in _d:
            matching_dirs.append(d)

    # check all inflation factors, localization functions, and sample sizes
    infl_facs = []
    sample_sizes = []
    loc_functions = []
    for d in matching_dirs:
        _d = d.split('_Ensemble_')[-1].split('_')
        sample_sizes.append(int(_d[0]))
        func = ' '.join(_d[1:-3])
        if func not in loc_functions:
            loc_functions.append(func)
        infl_facs.append(float('.'.join(_d[-2:])))
    infl_facs = list(set(infl_facs))
    infl_facs.sort()
    sample_sizes = list(set(sample_sizes))
    sample_sizes.sort()

    return infl_facs, sample_sizes, loc_functions

def read_from_results(base_results_dir):
    """
    """

    rmse_mat = np.empty((2, len(ensemble_size_pool), len(inflation_factors_pool)))
    rhist_uniformity_mat = np.empty((2, len(ensemble_size_pool), len(inflation_factors_pool), 3))
    num_experiments = len(ensemble_size_pool) * len(localization_function_pool) * len(inflation_factors_pool)
    exp_no = 0

    for e_ind, ensemble_size in enumerate(ensemble_size_pool):
        for f_ind, inflation_factor in enumerate(inflation_factors_pool):

            # Print some header
            results_dir = inspect_output_path(filter_name, inflation_factor, model_name, ensemble_size, localization_function)
            _, results_dir = os.path.split(results_dir)
            results_dir = os.path.join(base_results_dir, results_dir)

            sep = "\n%s(Reading %s Experiment Results [ %03d / %03d ]:)%s\n" % ('='*25, filter_name, exp_no, num_experiments, '='*25)
            print("Results from: %s\n" % (results_dir)),
            exp_no += 1

            if not os.path.isdir(results_dir):
                print("\nWARNING: Didn't find this results directory: %s !\n ...SKIPPING...\n" % results_dir)
                rmse_mat[:, e_ind, f_ind] = np.nan
                rhist_uniformity_mat[:, e_ind, f_ind, :] = np.nan
                continue
            else:
                os.rename(results_dir, standard_results_dir)

            # =====================================================================
            # Start reading the output of the assimilation process
            # =====================================================================
            _, _, reference_states, forecast_ensembles, _, analysis_ensembles, _, _, _, _, _, \
            forecast_rmse, analysis_rmse, _, _, _, _, _, _ = read_filter_output(out_dir_tree_structure_file)

            # Collect results:
            # 1- ensemble size vs. inflation factor -> RMSE, and distance to uniformity
            # Collect results:
            rmse_mat[0, e_ind, f_ind] = np.nanmean(forecast_rmse[init_time_ind:])
            rmse_mat[1, e_ind, f_ind] = np.nanmean(analysis_rmse[init_time_ind:])

            #

            f_out = utility.rank_hist(forecast_ensembles, reference_states, first_var=0,
                                                                            last_var=None,
                                                                            var_skp=5,
                                                                            draw_hist=False,
                                                                            hist_type='relfreq',
                                                                            first_time_ind=init_time_ind,
                                                                            last_time_ind=None,
                                                                            time_ind_skp=2)
            ranks_freq, _, bins_bounds , fig_hist = f_out[:]
            out = calc_kl_dist(ranks_freq, bins_bounds)
            forecast_rank_hist_kl_dist = [out[0], out[1][0], out[1][1]]
            # print(forecast_rank_hist_kl_dist)
            #
            for i in xrange(3):
                rhist_uniformity_mat[0, e_ind, f_ind, i] = forecast_rank_hist_kl_dist[i]

            #
            a_out = utility.rank_hist(analysis_ensembles, reference_states, first_var=0,
                                                                            last_var=None,
                                                                            var_skp=5,
                                                                            draw_hist=False,
                                                                            hist_type='relfreq',
                                                                            first_time_ind=init_time_ind,
                                                                            last_time_ind=None,
                                                                            time_ind_skp=2)
            ranks_freq, _, bins_bounds , fig_hist = a_out[:]
            out = calc_kl_dist(ranks_freq, bins_bounds)
            analysis_rank_hist_kl_dist = [out[0], out[1][0], out[1][1]]

            #
            for i in xrange(3):
                rhist_uniformity_mat[1, e_ind, f_ind, i] = analysis_rank_hist_kl_dist[i]


            # =====================================================================
            # Rename Results Directory back to original folder, and Cleanup
            # =====================================================================
            os.rename(standard_results_dir, results_dir)
            print("...DONE...\n%s\n" % ('='*len(sep)))
            # Cleanup:
            # del reference_states, forecast_ensembles, analysis_ensembles, forecast_rmse, analysis_rmse
            # =====================================================================
    return rmse_mat, rhist_uniformity_mat

def load_from_pickled(file_name):
    """
    """
    cont = pickle.load(open(file_name, 'rb'))
    rmse_mat = cont['rmse_mat']
    rhist_uniformity_mat = cont['rhist_uniformity_mat']
    # inflation_factors_pool = cont['inflation_factors_pool']
    # ensemble_size_pool = cont['ensemble_size_pool']
    # localization_function_pool = cont['localization_function_pool']
    return rmse_mat, rhist_uniformity_mat

def find_min_ranks(mat):
    """
    Given a 2D-matrix, find the location of the minimum across rows, and columns,
    Args:
        mat

    Returns:
        rows_min_ranks: rank of minimum value for each row
        cols_min_ranks: rank of minimum value for each column

    """
    assert np.ndim(mat) == 2, "mat must be 2-D np.ndarray"
    cols_mins = np.nanmin(mat, 0)  # minimum across columns
    rows_mins = np.nanmin(mat, 1)  # minimum across rows

    # find rank of minimum accross rows
    num_rows, num_cols = mat.shape
    rows_min_ranks, cols_min_ranks = [], []

    for row_ind in xrange(num_rows):
        vals = mat[row_ind, :]
        if np.isnan(vals).all():
            rnk = np.nan
        else:
            rnk = np.where(vals==rows_mins[row_ind])[0][0]
        rows_min_ranks.append(rnk)

    for col_ind in xrange(num_cols):
        vals = mat[:, col_ind]
        if np.isnan(vals).all():
            rnk = np.nan
        else:
            rnk = np.where(vals==cols_mins[col_ind])[0][0]
        cols_min_ranks.append(rnk)
    #
    #
    return rows_min_ranks, cols_min_ranks

def calc_kl_dist(ranks_freq, bins_bounds):
    """
    Calculate distance of a histogram, to a uniform rank histogram in 3 ways
    1- KL divergence between a fitted distribution, and a uniform distribution
    2- average distance between bins' heights and uniformly distributed bins
    3- average distance between sampled bins from a fitted Beta to the rank histogram, and uniform distribution.
    """
    data = []
    for fr, bn in zip(ranks_freq, bins_bounds):
        data += [float(bn)]*fr
    data = np.asarray(data)
    #
    dist = scipy.stats.beta
    params = dist.fit(data)

    betas = np.array([params[0], params[1]])
    B0 = betas.sum()

    alphas = np.array([1, 1])
    A0 = alphas.sum()
    KL_distance = sp.gammaln(A0) - np.sum(sp.gammaln(alphas)) \
                  - sp.gammaln(B0) + np.sum(sp.gammaln(betas)) \
                  + np.sum((alphas-betas) * (sp.digamma(alphas)-sp.digamma(A0)))

    ranks_rel_freq = ranks_freq*1.0 / ranks_freq.sum()
    # Calculate empirical distances:
    ens_size = len(bins_bounds) - 1
    try:
        random_sample = dist.rvs(params[0], params[1], size=1000)
        hist, freq = np.histogram(random_sample, bins=ens_size)
        rel_freq = freq/freq.sum()
        beta_avg_distances = np.mean(np.abs(ranks_rel_freq-rel_freq))
    except(ValueError):
        print("WARNING: Distance based on sampling Beta failed; using numpy.NaN")
        beta_avg_distances = np.nan

    avg_rel_freq = np.mean(ranks_rel_freq)
    empirical_distances = (np.mean(np.abs(ranks_rel_freq-avg_rel_freq)), beta_avg_distances)

    return KL_distance, empirical_distances


# if __name__ == '__main__':

filter_name = 'DEnKF'
model_name = 'lorenz'

base_results_dir = "./Results/EnKF_Results"
results_dir = os.path.join(base_results_dir, filter_name)
print("Looking into: ", results_dir)

init_time_ind = 100

rmse_thresh = 0.7
rhist_thresh = 2.5
log_scale = False
load_from_pickle = True

# Font, and Texts:
font_size = 22
font = {'family' : 'normal',
        'weight' : 'bold',
        'size'   : font_size}
#
matplotlib.rc('font', **font)
matplotlib.rc('text', usetex=True)
cmap = matplotlib.cm.jet
cmap.set_bad('white',1.)

rmse_vmin, rmse_vmax = 0, rmse_thresh
rhist_vmin, rhist_vmax = 0, rhist_thresh

# get list of results directories:
list_of_dirs = utility.get_list_of_subdirectories(results_dir, ignore_root=True, return_abs=False, ignore_special=True, recursive=False)
inflation_factors_pool, ensemble_size_pool, localization_function_pool = get_pools(list_of_dirs)

#
for localization_function in localization_function_pool:
    file_prefix = '%s_%s_Results_Localization_%s' % (model_name, filter_name, localization_function)
    file_name = '%s.pickle' % file_prefix
    file_name = os.path.join(results_dir, file_name)

    if load_from_pickle:
        rmse_mat, rhist_uniformity_mat = load_from_pickled(file_name)
    else:
        rmse_mat, rhist_uniformity_mat = read_from_results(results_dir)
        #
        # pickle Results:
        results_dict = {'rmse_mat':rmse_mat,
                        'rhist_uniformity_mat':rhist_uniformity_mat,
                        'inflation_factors_pool':inflation_factors_pool,
                        'ensemble_size_pool':ensemble_size_pool,
                        'localization_function_pool':localization_function_pool,
                        'init_time_ind':init_time_ind}
        pickle.dump(results_dict, open(file_name, 'wb'))

    # threshold rmse:
    try:
        rmse_mat[np.where(rmse_mat>rmse_thresh)] = np.nan
    except:
        # print("np.where(rmse_mat>rmse_thresh): ", np.where(rmse_mat>rmse_thresh))
        # raise
        pass
    try:
        rhist_uniformity_mat[np.where(rhist_uniformity_mat>rhist_thresh)] = np.nan
    except:
        # print("np.where(rhist_uniformity_mat>rhist_thresh): ", np.where(rhist_uniformity_mat>rhist_thresh))
        # raise
        pass

    # print('rmse_mat.shape', rmse_mat.shape)
    # print('rhist_uniformity_mat.shape', rhist_uniformity_mat.shape)

    print("Passing checkpoint")
    # RMSE min Ranks:
    inflation_factors_pool = np.asarray(inflation_factors_pool).flatten()
    ensemble_size_pool = np.asarray(ensemble_size_pool).flatten()
    rows_min_ranks, cols_min_ranks = find_min_ranks(rmse_mat[1, :, :])  # from analysis
    rmse_infl_fac_opt = []

    for r in rows_min_ranks:
        if np.isnan(r):
            rmse_infl_fac_opt.append(np.nan)
        else:
            rmse_infl_fac_opt.append(inflation_factors_pool[r])
    rmse_infl_fac_opt = np.array(rmse_infl_fac_opt)

    rmse_ens_size_opt = []
    for r in cols_min_ranks:
        if np.isnan(r):
            rmse_ens_size_opt.append(np.nan)
        else:
            rmse_ens_size_opt.append(ensemble_size_pool[r])
    rmse_ens_size_opt = np.array(rmse_ens_size_opt)


    # Rank Hist Ranks:
    rhist_infl_fac_opt_multi_crit = []
    rhist_ens_size_opt_multi_crit = []
    for i in xrange(3):
        rows_min_ranks, cols_min_ranks = find_min_ranks(rhist_uniformity_mat[1, :, :, i])  # from analysis
        rhist_infl_fac_opt = []
        for r in rows_min_ranks:
            if np.isnan(r):
                rhist_infl_fac_opt.append(np.nan)
            else:
                rhist_infl_fac_opt.append(inflation_factors_pool[r])
        rhist_infl_fac_opt = np.array(rhist_infl_fac_opt)
        rhist_infl_fac_opt_multi_crit.append(rhist_infl_fac_opt)

        rhist_ens_size_opt = []
        for r in cols_min_ranks:
            if np.isnan(r):
                rhist_ens_size_opt.append(np.nan)
            else:
                rhist_ens_size_opt.append(ensemble_size_pool[r])
        rhist_ens_size_opt = np.array(rhist_ens_size_opt)
        rhist_ens_size_opt_multi_crit.append(rhist_ens_size_opt)
    #
    legend_labels = [r"KL-Distance to $\mathcal{U}$",  r"Distance to $\mathcal{U}$", r"Distance of fitted $\beta$ to $\mathcal{U}$"]
    for i, rhist_ens_size_opt in enumerate(rhist_ens_size_opt_multi_crit):
        # Create a 2D-Plot with lines
        fig0 = plt.figure(facecolor='white')
        ax = fig0.add_subplot(111)
        #
        ax.set_xlabel("Ensemble Size")
        ax.set_ylabel("Inflation Factor")
        ax.set_xticks(ensemble_size_pool)
        ax.set_xticklabels(ensemble_size_pool)

        ms = 65
        ax.scatter(ensemble_size_pool, rmse_infl_fac_opt, ms, c='maroon', marker='^', label='RMSE')
        # ax.scatter(rmse_ens_size_opt, inflation_factors_pool, ms, c='olivedrab', marker='>', label=' ')

        kl_label = legend_labels[i]
        ax.scatter(ensemble_size_pool, rhist_infl_fac_opt_multi_crit[i], ms+10, c='darkblue', marker='2', label=kl_label)
        # ax.scatter(rhist_ens_size_opt_multi_crit[i], inflation_factors_pool, ms+10, c='red', marker='4', label=' ')

        # ax.legend(loc='best', fancybox=True, framealpha=0.5, fontsize=font_size-4)
        ax.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)
        #
        ax.yaxis.grid(True, linestyle='-', which='major', color='lightgrey', alpha=0.5)
        #
        file_name = '%s_analysis_rmse_scatter_%d.pdf' % (file_prefix, i)
        file_name = os.path.join(results_dir, file_name)
        print("Saving: %s" % file_name)
        plt.savefig(file_name, dpi=300, facecolor='w', format='pdf', transparent=True, bbox_inches='tight')
        #


    if log_scale:
        postfix = '_logscale'
    else:
        postfix = ''
    #
    grid_x = []
    for i in xrange(len(ensemble_size_pool)-1):
        grid_x.append((ensemble_size_pool[i]+ensemble_size_pool[i+1])/2.0)

    grid_y = []
    for i in xrange(len(inflation_factors_pool)-1):
        grid_y.append((inflation_factors_pool[i]+inflation_factors_pool[i+1])/2.0)


    extent = [ensemble_size_pool.min()-5, ensemble_size_pool.max()+5,
                inflation_factors_pool.min()-0.03, inflation_factors_pool.max()+0.03]

    extent = None

    # X and Y ticks, ticklabels:
    xticks = np.arange(0, len(ensemble_size_pool), max(len(ensemble_size_pool)/12, 1))
    xticklabels = [ensemble_size_pool[i] for i in xticks]
    yticks = np.arange(0, len(inflation_factors_pool), max(len(inflation_factors_pool)/10, 1))
    yticklabels = [inflation_factors_pool[i] for i in yticks]

    # extent = [ensemble_size_pool[0]-0.5*(ensemble_size_pool[1]-ensemble_size_pool[0]),
    #           ensemble_size_pool[-1]+0.5*(ensemble_size_pool[-1]-ensemble_size_pool[-2]),
    #           inflation_factors_pool[0]-0.5*(inflation_factors_pool[1]-inflation_factors_pool[0]),
    #           inflation_factors_pool[-1]+0.5*(inflation_factors_pool[-1]-inflation_factors_pool[-2])]

    #
    # Plot RMSE checkboards (forecast and analysis):
    if log_scale:
        data = np.log(rmse_mat[0,:,:].squeeze()).T
    else:
        data = rmse_mat[0,:,:].squeeze().T
    #
    fig1 = plt.figure(facecolor='white')
    ax = fig1.add_subplot(111)
    cax = ax.matshow(data, aspect='auto', origin='lower', extent=extent, interpolation='nearest', cmap=cmap)
    ax.set_xlabel("Ensemble Size")
    ax.set_ylabel("Inflation Factor")
    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels)
    ax.set_yticks(yticks)
    ax.set_yticklabels(yticklabels)
    ax.xaxis.set_ticks_position('bottom')
    # ax.set_xlim(ensemble_size_pool.min()-5, ensemble_size_pool.max()+5)
    # ax.set_ylim(inflation_factors_pool.min()-0.03, inflation_factors_pool.max()+0.03)
    fig1.colorbar(cax)
    #
    file_name = file_name = '%s_forecast_rmse%s.pdf' % (file_prefix, postfix)
    file_name = os.path.join(results_dir, file_name)
    print("Saving: %s" % file_name)
    plt.savefig(file_name, dpi=300, facecolor='w', format='pdf', transparent=True, bbox_inches='tight')

    # Plot RMSE checkboards (forecast and analysis):
    if log_scale:
        data = np.log(rmse_mat[1,:,:].squeeze()).T
    else:
        data = rmse_mat[1,:,:].squeeze().T
    #
    fig2 = plt.figure(facecolor='white')
    ax = fig2.add_subplot(111)
    cax = ax.matshow(data, aspect='auto', origin='lower', extent=extent, interpolation='nearest', cmap=cmap)
    ax.set_xlabel("Ensemble Size")
    ax.set_ylabel("Inflation Factor")
    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels)
    ax.set_yticks(yticks)
    ax.set_yticklabels(yticklabels)
    ax.xaxis.set_ticks_position('bottom')
    # ax.set_xlim(ensemble_size_pool.min()-5, ensemble_size_pool.max()+5)
    # ax.set_ylim(inflation_factors_pool.min()-0.03, inflation_factors_pool.max()+0.03)
    fig2.colorbar(cax)
    #
    file_name = file_name = '%s_analysis_rmse%s.pdf' % (file_prefix, postfix)
    file_name = os.path.join(results_dir, file_name)
    print("Saving: %s" % file_name)
    plt.savefig(file_name, dpi=300, facecolor='w', format='pdf', transparent=True, bbox_inches='tight')

    # Plot Rankhistogram uniformity checkboard:
    for i in xrange(3):
        data = rhist_uniformity_mat[0,:,:, i].squeeze().T
        #
        fig3 = plt.figure(facecolor='white')
        ax = fig3.add_subplot(111)
        cax = ax.matshow(data, aspect='auto', origin='lower', extent=extent, interpolation='nearest', cmap=cmap)
        ax.set_xlabel("Ensemble Size")
        ax.set_ylabel("Inflation Factor")
        ax.set_xticks(xticks)
        ax.set_xticklabels(xticklabels)
        ax.set_yticks(yticks)
        ax.set_yticklabels(yticklabels)
        ax.xaxis.set_ticks_position('bottom')
        # ax.set_xlim(ensemble_size_pool.min()-5, ensemble_size_pool.max()+5)
        # ax.set_ylim(inflation_factors_pool.min()-0.03, inflation_factors_pool.max()+0.03)
        fig3.colorbar(cax)
        #
        file_name = file_name = '%s_forecast_rhist_uniformity_%d.pdf' % (file_prefix, i)
        file_name = os.path.join(results_dir, file_name)
        print("Saving: %s" % file_name)
        plt.savefig(file_name, dpi=300, facecolor='w', format='pdf', transparent=True, bbox_inches='tight')

        data = rhist_uniformity_mat[1,:,:, i].squeeze().T
        #
        fig4 = plt.figure(facecolor='white')
        ax = fig4.add_subplot(111)
        cax = ax.matshow(data, aspect='auto', origin='lower', extent=extent, interpolation='nearest', cmap=cmap)
        ax.set_xlabel("Ensemble Size")
        ax.set_ylabel("Inflation Factor")
        ax.set_xticks(xticks)
        ax.set_xticklabels(xticklabels)
        ax.set_yticks(yticks)
        ax.set_yticklabels(yticklabels)
        ax.xaxis.set_ticks_position('bottom')
        # ax.set_xlim(ensemble_size_pool.min()-5, ensemble_size_pool.max()+5)
        # ax.set_ylim(inflation_factors_pool.min()-0.03, inflation_factors_pool.max()+0.03)
        fig4.colorbar(cax)
        #
        file_name = file_name = '%s_analysis_rhist_uniformity_%d.pdf' % (file_prefix, i)
        file_name = os.path.join(results_dir, file_name)
        print("Saving: %s" % file_name)
        plt.savefig(file_name, dpi=300, facecolor='w', format='pdf', transparent=True, bbox_inches='tight')

    plt.close('all')
    #

if False:
    localization_function = 'Gaspri-Cohn'
    file_prefix = '%s_%s_Results_Localization_%s' % (model_name, filter_name, localization_function)
    file_name = '%s.pickle' % file_prefix
    file_name = os.path.join(results_dir, file_name)
    rmse_mat, rhist_uniformity_mat = load_from_pickled(file_name)

    try:
        rmse_mat[np.where(rmse_mat>rmse_thresh)] = np.nan
    except:
        # print("np.where(rmse_mat>rmse_thresh): ", np.where(rmse_mat>rmse_thresh))
        # raise
        pass
    try:
        rhist_uniformity_mat[np.where(rhist_uniformity_mat>rhist_thresh)] = np.nan
    except:
        # print("np.where(rhist_uniformity_mat>rhist_thresh): ", np.where(rhist_uniformity_mat>rhist_thresh))
        # raise
        pass

    # print('rmse_mat.shape', rmse_mat.shape)
    # print('rhist_uniformity_mat.shape', rhist_uniformity_mat.shape)

    print("Passing checkpoint")
    # RMSE min Ranks:
    inflation_factors_pool = np.asarray(inflation_factors_pool).flatten()
    ensemble_size_pool = np.asarray(ensemble_size_pool).flatten()
    rows_min_ranks, cols_min_ranks = find_min_ranks(rmse_mat[1, :, :])  # from analysis
    rmse_infl_fac_opt = []

    for r in rows_min_ranks:
        if np.isnan(r):
            rmse_infl_fac_opt.append(np.nan)
        else:
            rmse_infl_fac_opt.append(inflation_factors_pool[r])
    rmse_infl_fac_opt = np.array(rmse_infl_fac_opt)

    rmse_ens_size_opt = []
    for r in cols_min_ranks:
        if np.isnan(r):
            rmse_ens_size_opt.append(np.nan)
        else:
            rmse_ens_size_opt.append(ensemble_size_pool[r])
    rmse_ens_size_opt = np.array(rmse_ens_size_opt)


    # Rank Hist Ranks:
    rhist_infl_fac_opt_multi_crit = []
    rhist_ens_size_opt_multi_crit = []
    for i in xrange(3):
        rows_min_ranks, cols_min_ranks = find_min_ranks(rhist_uniformity_mat[1, :, :, i])  # from analysis
        rhist_infl_fac_opt = []
        for r in rows_min_ranks:
            if np.isnan(r):
                rhist_infl_fac_opt.append(np.nan)
            else:
                rhist_infl_fac_opt.append(inflation_factors_pool[r])
        rhist_infl_fac_opt = np.array(rhist_infl_fac_opt)
        rhist_infl_fac_opt_multi_crit.append(rhist_infl_fac_opt)

        rhist_ens_size_opt = []
        for r in cols_min_ranks:
            if np.isnan(r):
                rhist_ens_size_opt.append(np.nan)
            else:
                rhist_ens_size_opt.append(ensemble_size_pool[r])
        rhist_ens_size_opt = np.array(rhist_ens_size_opt)
        rhist_ens_size_opt_multi_crit.append(rhist_ens_size_opt)


    # Plot RMSE checkboards (forecast and analysis):
    if log_scale:
        data = np.log(rmse_mat[1,:,:].squeeze()).T
    else:
        data = rmse_mat[1,:,:].squeeze().T
    #
    plt.interactive(True)
    group_fig, group_axes = plt.subplots(1, 2, facecolor='white')
    ax = group_axes[0,0]
    cax = ax.matshow(data, aspect='auto', origin='lower', extent=extent, interpolation='nearest', cmap=cmap)
    ax.set_xlabel("Ensemble Size")
    ax.set_ylabel("Inflation Factor")
    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels)
    ax.set_yticks(yticks)
    ax.set_yticklabels(yticklabels)
    ax.xaxis.set_ticks_position('bottom')
    group_fig.colorbar(cax)

    data = rhist_uniformity_mat[1,:,:, 0].squeeze().T
    #
    fig4 = plt.figure(facecolor='white')
    ax = fig4.add_subplot(111)
    cax = ax.matshow(data, aspect='auto', origin='lower', extent=extent, interpolation='nearest', cmap=cmap)
    ax.set_xlabel("Ensemble Size")
    ax.set_ylabel("Inflation Factor")
    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels)
    ax.set_yticks(yticks)
    ax.set_yticklabels(yticklabels)
    ax.xaxis.set_ticks_position('bottom')
    group_fig.colorbar(cax)

